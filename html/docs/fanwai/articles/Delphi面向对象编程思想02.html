<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="generator" content="VNote">

    <title>Delphi面向对象编程思想02</title>
    <link rel="icon" href="https://github.com/tamlok/vnote/raw/master/src/resources/icons/vnote.ico">

    <style type="text/css">
    body { background-color: transparent !important; }

    </style>

    <style type="text/css">
    /* STYLE_OUTLINE_PLACE_HOLDER */
    /* STYLE_PLACE_HOLDER */
    </style>

    <!-- EXTRA_PLACE_HOLDER -->

<!-- HEAD_PLACE_HOLDER -->
</head>
<body>
<div class="container-fluid">
<div class="row flex-xl-nowrap">
    <div id="outline-panel" style="display:none;" class="d-none d-md-block d-xl-block col-md-3 col-xl-2 bd-toc">
        <div id="outline-content" class="section-nav"></div>
    </div>
    <div id="post-content" class="col-12 col-md-9 col-xl-10 py-md-3 pl-md-5 bd-content">
    <p>界面和业务的分离是开发可维护、易扩展、长寿命应用系统的关键，也是实现多层分布式系统的必经之路。面向对象编程技术为开发界面和业务分离的系统提供了行之有效的途径</p>
<blockquote>
<p>以上内容摘自原书</p>
</blockquote>
<p>在逻辑上，代码的封装是通过类来实现的，类通过属性封装了对象的数据，类通过方法封装了对象的行为。在屋里上，代码可以封装在可执行文件中(.exe)、动态链接库中(.dll)、也可以封装在COM+组件中，而对代码或程序的封装，我们在上一篇文章中也提到过主要是在于实现易开发、可维护、能服用的软件模式</p>
<p>一个设计良好的应用程序在逻辑上应该至少划分为界面和业务两个层次。界面和业务的分离将十分有利于系统的维护和扩展，体现灵活、复用的风格。一个面向对象的程序比传统的面向函数和过程的程序更易于实现界面和业务的分离</p>
<p>通常的软件系统划分为3层，即：表现层(或者称为表示层)、业务层和数据层，如下图所示</p>
<ul>
<li>
<p>表现层：主要用于和用户交互，它提供用户界面及操作导航服务，它的主要选项是win32客户机和基于浏览器的客户机</p>
</li>
<li>
<p>业务层：主要用于业务处理，提供商业逻辑等各种约束</p>
</li>
<li>
<p>数据层：主要用于数据的集成存储，这些数据既可以是文件，也可以是数据</p>
</li>
</ul>
<p><img src="_v_images/20200115111905667_16582.png" alt="" class="view-image"></p>
<h4 id="toc_0">一个HelloWorld案例<a class="vnote-anchor" href="#toc_0" data-anchor-icon="#"></a></h4>
<p>该案例就一个目的，实现DLL中导出一个对象，尝试实现功能模块分离，我自己有一个习惯就是，在学习任何新东西之初都会先跑一个HelloWorld的 案例，在不掺杂其他复杂的业务功能之前能够跑通的话至少说明思路、环境没有问题，剩下的就是在这个基础上进行扩展了，根据上面分析的思路，我们来写一个</p>
<p>项目整体的目录结构</p>
<pre><code class="hljs">ProjectGroup
    |--- MainProject.dproj
        |---public
            |---UnitPublic.pas
        |---frmMain.pas

    |--- ProjectDll.dproj

</code></pre>
<blockquote>
<p>这个案例中没有所谓的持久层，仅仅是一个案例，没有牵扯到文件读写或者数据库数据处理</p>
</blockquote>
<p>具体的代码实现</p>
<ul>
<li>可执行文件所在的项目代码(MainProject)</li>
</ul>
<blockquote>
<p>public文件夹下的UnitPublic单元中的代码如下</p>
</blockquote>
<pre><code class="lang-pascal hljs"><span class="hljs-comment">//需要注意的是这个单元最好存放的全部都是接口，而不存放其他的内容，接口的主要目的可以当做exe和dll两个项目实现单元共享的桥梁</span>
<span class="hljs-keyword">type</span>
  IUtile = <span class="hljs-keyword">interface</span>
    [<span class="hljs-string">'{BF70EF99-0F0C-4726-B29B-56E665C8496A}'</span>]

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ShowMessage</span><span class="hljs-params">()</span>:</span> <span class="hljs-keyword">string</span>;
  <span class="hljs-keyword">end</span>;

<span class="hljs-keyword">implementation</span>

<span class="hljs-keyword">end</span>.
</code></pre>
<blockquote>
<p>exe项目文件的代码如下</p>
</blockquote>
<pre><code class="lang-pascal hljs"><span class="hljs-comment">//...  只存放实现部分的代码，interface部分的代码不变，全复制太多了</span>
<span class="hljs-keyword">implementation</span>
<span class="hljs-keyword">uses</span>
  UnitPublic;
<span class="hljs-meta">{$R *.dfm}</span>

<span class="hljs-comment">//我们引入DLL中的一个导出函数，而该函数返回的数据类型是一个接口类型</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetPublicUtil</span><span class="hljs-params">()</span>:</span> IUtile; <span class="hljs-keyword">stdcall</span>; <span class="hljs-keyword">external</span> <span class="hljs-string">'ProjectDll.dll'</span>;

<span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">TForm1</span>.<span class="hljs-title">Button1Click</span><span class="hljs-params">(Sender: TObject)</span>;</span>
<span class="hljs-keyword">begin</span>

  ShowMessage(GetPublicUtil().ShowMessage());
<span class="hljs-keyword">end</span>;

<span class="hljs-keyword">end</span>.
</code></pre>
<blockquote>
<p>dll项目中的代码如下</p>
</blockquote>
<pre><code class="lang-pascal hljs"><span class="hljs-keyword">library</span> ProjectDll;

<span class="hljs-comment">//这里唯一的难题就是我们需要引用UnitPublic单元，而该单元是在另外一个项目的，解决办法指定对应的路径即可</span>
<span class="hljs-keyword">uses</span>
  UnitPublic <span class="hljs-keyword">in</span> <span class="hljs-string">'../MainProject/public/UnitPublic.pas'</span>,
  System.SysUtils,
  System.Classes;


<span class="hljs-meta">{$R *.res}</span>

<span class="hljs-keyword">type</span>
   <span class="hljs-comment">//实现对应的接口，重写对应的抽象方法</span>
  <span class="hljs-title">TPublicUtil</span> = <span class="hljs-keyword">class</span>(TInterfacedObject, IUtile)
  <span class="hljs-keyword">public</span>
      <span class="hljs-comment">//注意该方法是接口中定义的抽象方法，如果该方法一旦被调用成功，那么也就意味着我们整个流程跑通</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ShowMessage</span><span class="hljs-params">()</span>:</span> <span class="hljs-keyword">string</span>;
  <span class="hljs-keyword">end</span>;

<span class="hljs-comment">{ TPublicUtil }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TPublicUtil</span>.<span class="hljs-title">ShowMessage</span>:</span> <span class="hljs-keyword">string</span>;
<span class="hljs-keyword">begin</span>
  Result := <span class="hljs-string">'HelloWorld'</span>;
<span class="hljs-keyword">end</span>;

<span class="hljs-comment">//这个函数才是整个的核心，其返回值返回的是接口实现类的对象，根据多态的特性，父类类型是可以接收子类对象的</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetPublicUtil</span><span class="hljs-params">()</span>:</span> IUtile; <span class="hljs-keyword">stdcall</span>;
<span class="hljs-keyword">begin</span>
  Result := TPublicUtil.Create;
<span class="hljs-keyword">end</span>;

<span class="hljs-comment">//导出函数列表</span>
<span class="hljs-keyword">exports</span>
  GetPublicUtil;
</code></pre>
<h4 id="toc_1">逻辑分离<a class="vnote-anchor" href="#toc_1" data-anchor-icon="#"></a></h4>
<p>如果一个项目的代码较少(这里是相对于大型项目来说的)，那么我们可以考虑不再实现物理分离，仅仅做一个逻辑分离，按照各自功能的不同划分对应的单元即可，下面这张图是用于说明</p>
<p><img src="_v_images/20200115111803556_7007.png" alt="" class="view-image"></p>
<h4 id="toc_2">物理分离<a class="vnote-anchor" href="#toc_2" data-anchor-icon="#"></a></h4>
<p>在大型项目中，我们除了逻辑分离之外那么久必须还要进行物理分离，所谓的物理分离就是我们不光对使用频率较高的功能进行模块封装之外还要将其以dll或者其他的文件表达方式进行封装，好处当然还是 代码复用，现在大家考虑更多的可能是自己完成某一个软件，但是现在很多时候已经不是单兵作战了</p>
<p><img src="_v_images/20200115111715979_3723.png" alt="" class="view-image"></p>
<blockquote>
<p>总结：上面我们进行了各种思路的分离，除了我们在做日常开发时需要的某些扩展维护之外，书上还简单的阐述了利用webservice实现分布式软件架构的开发，这个不在我们现在的讨论范围之内，因为它是一个很大的话题，单单分布式就可以写本书了</p>
</blockquote>

    </div>
</div>
</div>

<div id="container-floating" style="display:none;" class="d-none d-md-block d-xl-block">
    <div id="floating-button" onclick="toggleMore()">
        <p id="floating-more" class="more">&gt;</p>
    </div>
</div>

<!--
<div class="footer" id="vnote-footer">
    <p>Generated by <em><a href="https://tamlok.github.io/vnote/">VNote</a></em>.</p>
</div>
-->
</body>
</html>
