<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="generator" content="VNote">

    <title>单例设计模式二</title>
    <link rel="icon" href="https://github.com/tamlok/vnote/raw/master/src/resources/icons/vnote.ico">

    <style type="text/css">
    /* STYLE_GLOBAL_PLACE_HOLDER */
    </style>

    <style type="text/css">
    /* STYLE_OUTLINE_PLACE_HOLDER */
    /* STYLE_PLACE_HOLDER */
    </style>

    <!-- EXTRA_PLACE_HOLDER -->

<!-- HEAD_PLACE_HOLDER -->
</head>
<body>
<div class="container-fluid">
<div class="row flex-xl-nowrap">
    <div id="outline-panel" style="display:none;" class="d-none d-md-block d-xl-block col-md-3 col-xl-2 bd-toc">
        <div id="outline-content" class="section-nav"></div>
    </div>
    <div id="post-content" class="col-12 col-md-9 col-xl-10 py-md-3 pl-md-5 bd-content">
    <p>​接上篇，细心的朋友可能发现我在上一篇文章中重写类NewInstance和FreeInstance函数，原因是：【在delphi中编译器对构造函数的保护级别进行了处理，即便设为private，编译器仍然会将其修正为public，所以覆盖基类中的NewInstance类方法，系统在每次构造对象时都会调用这个类方法，通过重载它就可以实现对构造函数的控制】，同时在上篇文章中有一段核心代码</p>
<p><img src="_v_images/20210606134725347_3701" alt="" class="view-image"></p>
<p>我以注释的形式标注这里在并发环境下存在安全隐患，那么现在我们就通过多线程的方式研究一下这个问题？具体做法就是我创建10个线程，反复的调用这个函数</p>
<h1 id="toc_0">调整代码<a class="vnote-anchor" href="#toc_0" data-anchor-icon="#"></a></h1>
<p>因为现在的CPU执行速度很快，而我们的代码又不是什么复杂的运算，所以通过添加延时的方式模拟</p>
<p><img src="_v_images/20210606134724841_9469" alt="" class="view-image"></p>
<h1 id="toc_1">测试代码<a class="vnote-anchor" href="#toc_1" data-anchor-icon="#"></a></h1>
<p><img src="_v_images/20210606134724235_11396" alt="" class="view-image"></p>
<h1 id="toc_2">执行结果<a class="vnote-anchor" href="#toc_2" data-anchor-icon="#"></a></h1>
<p><img src="_v_images/20210606134723624_4274" alt="" class="view-image"></p>
<blockquote>
<p>结论：我们发现当以多线程的方式访问时出现了创建多个TSingle类对象的情况，这就是我前面提的并发环境下的安全问题</p>
</blockquote>
<h1 id="toc_3">原因分析<a class="vnote-anchor" href="#toc_3" data-anchor-icon="#"></a></h1>
<p><img src="_v_images/20210606134722920_23076" alt="" class="view-image"></p>
<h1 id="toc_4">解决方案<a class="vnote-anchor" href="#toc_4" data-anchor-icon="#"></a></h1>
<p>解决方案主要有两种</p>
<ul>
<li>
<p>通过同步锁(线程锁)的方式解决，但是这种方式会存在效率的问题，我们知道一旦代码需要同步的时其实就是以单线程的方式在执行</p>
</li>
<li>
<p>通过内部类的方式解决，这种方式解释起来比较费劲，我也没有深究过Delphi类的加载机制</p>
</li>
</ul>
<h2 id="toc_5">同步锁<a class="vnote-anchor" href="#toc_5" data-anchor-icon="#"></a></h2>
<p>临界区对象初始化和销毁</p>
<p><img src="_v_images/20210606134722414_18100" alt="" class="view-image"></p>
<p><img src="_v_images/20210606134721811_9607" alt="" class="view-image"></p>
<pre><code class="lang-pascal hljs"><span class="hljs-keyword">class</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TSingle</span>.<span class="hljs-title">GetInstance</span>:</span> TSingle;
<span class="hljs-keyword">begin</span>
    <span class="hljs-comment">//临界区开始</span>
    CriticalSection.Enter;
    <span class="hljs-keyword">if</span> GlobalSingle = <span class="hljs-keyword">nil</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">//添加延迟模拟多线程暂留</span>
        TThread.Sleep(<span class="hljs-number">1000</span>);
        GlobalSingle := TSingle.create();
    <span class="hljs-keyword">end</span>;
​
    <span class="hljs-comment">//临界区结束</span>
    CriticalSection.Leave;
​
    Result := GlobalSingle;
<span class="hljs-keyword">end</span>;
</code></pre>
<blockquote>
<p>测试的代码不变，我们会发现问题已经成功的被解决了</p>
</blockquote>
<h2 id="toc_6">内部类<a class="vnote-anchor" href="#toc_6" data-anchor-icon="#"></a></h2>
<p>完整的代码如下：</p>
<p><strong>uCommonUtil单元</strong></p>
<pre><code class="lang-pascal hljs"><span class="hljs-keyword">unit</span> uCommonUtil;
​
<span class="hljs-keyword">interface</span>
​
<span class="hljs-keyword">uses</span>
    system.SyncObjs, System.Classes, System.SysUtils;
​
<span class="hljs-keyword">type</span>
    <span class="hljs-title">TStringBuild</span> = <span class="hljs-keyword">class</span>(TObject)
    <span class="hljs-keyword">private</span>
        <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">Create</span>;</span>
    <span class="hljs-keyword">public</span>
        <span class="hljs-comment">//其实这个地方可以设置为private的然后提供一个public的函数，偷个懒</span>
        <span class="hljs-keyword">type</span>
            Build = <span class="hljs-keyword">class</span>
                <span class="hljs-comment">//注意函数的返回值</span>
                <span class="hljs-keyword">class</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span>:</span> TStringBuild;
            <span class="hljs-keyword">end</span>;
        <span class="hljs-keyword">class</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NewInstance</span>:</span> TObject; <span class="hljs-keyword">override</span>;
        <span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">FreeInstance</span>;</span> <span class="hljs-keyword">override</span>;
    <span class="hljs-keyword">end</span>;
​
<span class="hljs-keyword">implementation</span>
​
<span class="hljs-keyword">var</span>
​
    <span class="hljs-comment">{ TStringBuild }</span>
    StringBuild: TStringBuild = <span class="hljs-keyword">nil</span>;
​
<span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">TStringBuild</span>.<span class="hljs-title">Create</span>;</span>
<span class="hljs-keyword">begin</span>
    Writeln(<span class="hljs-string">'TStringBuild的构造方法'</span>);
<span class="hljs-keyword">end</span>;
​
<span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">TStringBuild</span>.<span class="hljs-title">FreeInstance</span>;</span>
<span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">inherited</span>;
    StringBuild := <span class="hljs-keyword">nil</span>;
<span class="hljs-keyword">end</span>;
​
<span class="hljs-keyword">class</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TStringBuild</span>.<span class="hljs-title">NewInstance</span>:</span> TObject;
<span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> StringBuild = <span class="hljs-keyword">nil</span> <span class="hljs-keyword">then</span>
        <span class="hljs-comment">//重载方法通过父类  NewInstance方法获取对象，强制转换为 TSingle类型</span>
        StringBuild := TStringBuild(<span class="hljs-keyword">inherited</span> NewInstance);
    Result := StringBuild;
<span class="hljs-keyword">end</span>;
​
<span class="hljs-comment">//内部类的类方法</span>
<span class="hljs-keyword">class</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TStringBuild</span>.<span class="hljs-title">Build</span>.<span class="hljs-title">GetInstance</span>:</span> TStringBuild;
<span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> StringBuild = <span class="hljs-keyword">nil</span> <span class="hljs-keyword">then</span>
        StringBuild := TStringBuild.create();
    Result := StringBuild;
<span class="hljs-keyword">end</span>;
​
<span class="hljs-keyword">initialization</span>
​
<span class="hljs-keyword">finalization</span>
​
<span class="hljs-keyword">end</span>.
</code></pre>
<p><strong>测试单元</strong></p>
<pre><code class="lang-pascal hljs">
​<span class="hljs-keyword">program</span> ProjectSingle;
​
<span class="hljs-meta">{$APPTYPE CONSOLE}</span>
<span class="hljs-meta">{$R *.res}</span>
​
<span class="hljs-keyword">uses</span>
    System.Classes,
    System.SysUtils,
    System.Types,
    uCommonUtil <span class="hljs-keyword">in</span> <span class="hljs-string">'uCommonUtil.pas'</span>;
​
<span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">Demo2</span><span class="hljs-params">()</span>;</span>
<span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">try</span>
​
        <span class="hljs-keyword">for</span> <span class="hljs-keyword">var</span> I := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> <span class="hljs-number">100</span> <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span>
            TThread.CreateAnonymousThread(
                <span class="hljs-function"><span class="hljs-keyword">procedure</span>
                <span class="hljs-title">begin</span>
                    <span class="hljs-title">var</span> <span class="hljs-title">instance</span> :</span>= TStringBuild.Build.GetInstance();
​
                    writeln(IntToStr(TThread.CurrentThread.ThreadID) + <span class="hljs-string">'：'</span> + IntToStr(Integer(instance)));
                <span class="hljs-keyword">end</span>).Start;
        <span class="hljs-keyword">end</span>;
​
    <span class="hljs-keyword">except</span>
        <span class="hljs-keyword">on</span> e: Exception <span class="hljs-keyword">do</span>
            writeln(e.<span class="hljs-keyword">Message</span>);
    <span class="hljs-keyword">end</span>;
​
    readln;
<span class="hljs-keyword">end</span>;
​
<span class="hljs-keyword">begin</span>
    Demo2();
<span class="hljs-keyword">end</span>.
</code></pre>
<p><strong>执行结果</strong></p>
<p><img src="_v_images/20210606134721307_27220" alt="" class="view-image"></p>
<blockquote>
<p>以内部类的方式来解决貌似是我现在能够想到最靠谱的解决方案了，各位有什么好的方法可以给我留言</p>
</blockquote>

    </div>
</div>
</div>

<div id="container-floating" style="display:none;" class="d-none d-md-block d-xl-block">
    <div id="floating-button" onclick="toggleMore()">
        <p id="floating-more" class="more">&gt;</p>
    </div>
</div>

<!--
<div class="footer" id="vnote-footer">
    <p>Generated by <em><a href="https://tamlok.github.io/vnote/">VNote</a></em>.</p>
</div>
-->
</body>
</html>
