<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="generator" content="VNote">

    <title>007-变量和方法总结</title>
    <link rel="icon" href="https://github.com/tamlok/vnote/raw/master/src/resources/icons/vnote.ico">

    <style type="text/css">
    /* STYLE_GLOBAL_PLACE_HOLDER */
    </style>

    <style type="text/css">
    /* STYLE_OUTLINE_PLACE_HOLDER */
    /* STYLE_PLACE_HOLDER */
    </style>

    <!-- EXTRA_PLACE_HOLDER -->

<!-- HEAD_PLACE_HOLDER -->
</head>
<body>
<div class="container-fluid">
<div class="row flex-xl-nowrap">
    <div id="outline-panel" style="display:none;" class="d-none d-md-block d-xl-block col-md-3 col-xl-2 bd-toc">
        <div id="outline-content" class="section-nav"></div>
    </div>
    <div id="post-content" class="col-12 col-md-9 col-xl-10 py-md-3 pl-md-5 bd-content">
    <h2 id="toc_0">关键字static<a class="vnote-anchor" href="#toc_0" data-anchor-icon="#"></a></h2>
<p>static可以修饰类的成员：类的成员我们指成员变量(全局变量)、成员方法</p>
<p>静态和非静态的区别：他们加载到内存的顺序和时机不同</p>
<ul>
<li>静态的成员会先被加载,它是跟着类的加载而加载的,该类型的成员终身只加载一次</li>
<li>非静态成员是随着对象的建立而被加载的,创建了多少次对象,非静态成员就加载多少次</li>
</ul>
<p>静态成员和非静态成员的调用规则</p>
<ul>
<li>
<p>静态成员无法调用非静态成员</p>
</li>
<li>
<p>在同一个类中,几乎没有区别,都是直接以【方法名()】的形式调用,在不同类中调用</p>
<ul>
<li>静态成员		类名.成员名	<code>Test01.show02();</code></li>
<li>非静态成员		必须先创建非静态成员所在类的对象 对象.成员名称，<code>new Test01().show01();</code></li>
</ul>
</li>
</ul>
<h2 id="toc_1">划分<a class="vnote-anchor" href="#toc_1" data-anchor-icon="#"></a></h2>
<ol>
<li>根据类型进行划分</li>
</ol>
<p>基本数据类型：</p>
<ul>
<li>
<p>整数、小数、字符、逻辑</p>
</li>
<li>
<p>数据类型转换：实际编程时尽量避免</p>
<ul>
<li>自动转换</li>
<li>强制转换<br>
引用数据类型：</li>
</ul>
</li>
</ul>
<p>默认值是null</p>
<ol start="2">
<li>根据变量的作用范围进行划分</li>
</ol>
<ul>
<li>
<p>全局变量、成员变量、属性：直接在类下面进行声明的变量</p>
</li>
<li>
<p>局部变量:定义在方法内部或者语句中的变量</p>
</li>
<li>
<p>区别：全局变量在定义时,可以不赋值,因为Java会自动取该变量类型的默认值赋值给该变量</p>
</li>
</ul>
<h2 id="toc_2">变量值的传递<a class="vnote-anchor" href="#toc_2" data-anchor-icon="#"></a></h2>
<p>传递变量的具体值：基本数据类型</p>
<p>传递的是对象(内存地址)：引用数据类型</p>
<h2 id="toc_3">参数列表<a class="vnote-anchor" href="#toc_3" data-anchor-icon="#"></a></h2>
<ol>
<li>
<p>主要作用：两个方法之间用进行数据传输的通道</p>
</li>
<li>
<p>当我们编写方法时,首先我们确定要书写的方法功能,其次考虑需要哪些参数</p>
</li>
</ol>
<h2 id="toc_4">返回值(return)<a class="vnote-anchor" href="#toc_4" data-anchor-icon="#"></a></h2>
<ul>
<li>终止的方法继续运行,每个方法都有return,构造方法除外,当我们使用返回值类型是void时,return可以省略不写</li>
<li>向本方法的调用者提供一个值,该值有可能是一个空值(null)</li>
</ul>
<h2 id="toc_5">方法的归类<a class="vnote-anchor" href="#toc_5" data-anchor-icon="#"></a></h2>
<ol>
<li>普通方法</li>
</ol>
<p>声明方式：访问权限修饰符 返回值类型 (方法名参数列表) {方法体} public void show(){}</p>
<ol start="2">
<li>静态方法</li>
</ol>
<p>声明方式：访问权限修饰符 static 返回值类型 (方法名参数列表) {方法体} public static void show(){}</p>
<ol start="3">
<li>构造方法</li>
</ol>
<ul>
<li>
<p>作用：</p>
<ul>
<li>创建对象</li>
<li>给成员变量进行初始化赋值</li>
</ul>
</li>
<li>
<p>声明方式</p>
<ul>
<li>没有返回值</li>
<li>方法名和类名相同</li>
</ul>
</li>
</ul>
<blockquote>
<p>空参空实现(默认构造)：</p>
</blockquote>
<blockquote>
<p>当一个类中没有构造方法时(我们没有手动的创建),Java虚拟机会帮我们自动添加一个</p>
</blockquote>
<h2 id="toc_6">重载<a class="vnote-anchor" href="#toc_6" data-anchor-icon="#"></a></h2>
<p>当两个或者两个以上的方法满足以下要求时我们称为重载</p>
<ul>
<li>方法名相同</li>
<li>参数列表不同:参数个数或者参数类型不同</li>
</ul>
<h2 id="toc_7">代码块<a class="vnote-anchor" href="#toc_7" data-anchor-icon="#"></a></h2>
<p>代码块声明方式：<code>{}</code></p>
<p>静态代码块声明方式：<code>static{}</code></p>
<p>作用同构造方法</p>
<blockquote>
<p>总结：普通和静态方法的主要作用是用来封装代码片段,更多的时候是一个单一的功能模块,注意和构造方法作用的区别</p>
</blockquote>
<h2 id="toc_8">学生信息管理系统(基础编程结束)<a class="vnote-anchor" href="#toc_8" data-anchor-icon="#"></a></h2>
<p>核心功能分析出来：CRUD即添加、查询、修改、删除</p>

    </div>
</div>
</div>

<div id="container-floating" style="display:none;" class="d-none d-md-block d-xl-block">
    <div id="floating-button" onclick="toggleMore()">
        <p id="floating-more" class="more">&gt;</p>
    </div>
</div>

<!--
<div class="footer" id="vnote-footer">
    <p>Generated by <em><a href="https://tamlok.github.io/vnote/">VNote</a></em>.</p>
</div>
-->
</body>
</html>
