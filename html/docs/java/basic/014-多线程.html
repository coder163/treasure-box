<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="generator" content="VNote">

    <title>014-多线程</title>
    <link rel="icon" href="https://github.com/tamlok/vnote/raw/master/src/resources/icons/vnote.ico">

    <style type="text/css">
    /* STYLE_GLOBAL_PLACE_HOLDER */
    </style>

    <style type="text/css">
    /* STYLE_OUTLINE_PLACE_HOLDER */
    /* STYLE_PLACE_HOLDER */
    </style>

    <!-- EXTRA_PLACE_HOLDER -->

<!-- HEAD_PLACE_HOLDER -->
</head>
<body>
<div class="container-fluid">
<div class="row flex-xl-nowrap">
    <div id="outline-panel" style="display:none;" class="d-none d-md-block d-xl-block col-md-3 col-xl-2 bd-toc">
        <div id="outline-content" class="section-nav"></div>
    </div>
    <div id="post-content" class="col-12 col-md-9 col-xl-10 py-md-3 pl-md-5 bd-content">
    <p>程序：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</p>
<p>进程：是程序的一次执行过程，或是正在运行的一个程序</p>
<p>线程：一个进程中同时执行不同的代码片段,对于这些正在运行的代码片段我们称为线程,一个进程中至少有一个线程在运行</p>
<h2 id="toc_0">Java中如何创建线程<a class="vnote-anchor" href="#toc_0" data-anchor-icon="#"></a></h2>
<h3 id="toc_1">通过继承Thread类<a class="vnote-anchor" href="#toc_1" data-anchor-icon="#"></a></h3>
<p><img src="_v_images/20190311210400808_6392.png" alt="" class="view-image"></p>
<p><img src="_v_images/20190311210414142_9506.png" alt="" class="view-image"></p>
<h3 id="toc_2">通过实现Runnable接口<a class="vnote-anchor" href="#toc_2" data-anchor-icon="#"></a></h3>
<p><img src="_v_images/20190311210503964_24565.png" alt="" class="view-image"><br>
<img src="_v_images/20190311210515453_14846.png" alt="" class="view-image"></p>
<p>实现接口方式启动线程的优势</p>
<ul>
<li>避免了单继承的局限性</li>
<li>多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。</li>
</ul>
<h2 id="toc_3">名词解释<a class="vnote-anchor" href="#toc_3" data-anchor-icon="#"></a></h2>
<ul>
<li>线程同步：同一时刻只能有一个线程在执行</li>
<li>线程异步：同一时刻可以有多个线程在执行,例如：百度云、迅雷</li>
<li>线程通讯：多个线程之间借助某一对象实现数据交互</li>
<li>线程同步：主要通过对象锁解决线程安全问题,虽然安全问题可以解决,但是执行效率低</li>
</ul>
<h2 id="toc_4">线程的状态<a class="vnote-anchor" href="#toc_4" data-anchor-icon="#"></a></h2>
<p><img src="_v_images/20190311210613938_21261.png" alt="" class="view-image"></p>
<blockquote>
<p>多线程内部是抢占式的执行</p>
</blockquote>
<h2 id="toc_5">线程控制<a class="vnote-anchor" href="#toc_5" data-anchor-icon="#"></a></h2>
<p>借助Object类和Thread类中的一些API方法,实现对多线程的控制</p>
<p><img src="_v_images/20190311210748745_5475.png" alt="" class="view-image"><br>
<img src="_v_images/20190311210802503_20741.png" alt="" class="view-image"><br>
<img src="_v_images/20190311210819508_31037.png" alt="" class="view-image"><br>
<img src="_v_images/20190311210827498_5679.png" alt="" class="view-image"></p>
<p>在Java 5.0 提供了java.util.concurrent（简称JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的 Collection 实现等。</p>
<h2 id="toc_6">关键字 volatile<a class="vnote-anchor" href="#toc_6" data-anchor-icon="#"></a></h2>
<p>内存可见性</p>
<ul>
<li>
<p>内存可见性（Memory Visibility）是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p>
</li>
<li>
<p>可见性错误是指当读操作与写操作在不同的线程中执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。</p>
</li>
<li>
<p>我们可以通过同步来保证对象被安全地发布。除此之外我们也可以使用一种更加轻量级的volatile 变量。</p>
</li>
</ul>
<p>volatile 关键字</p>
<ul>
<li>
<p>Java提供了一种稍弱的同步机制，即volatile 变量，用来确保将变量的更新操作通知到其他线程。可以将volatile 看做一个轻量级的锁，但是又与锁有些不同：</p>
<ol>
<li>对于多线程，不是一种互斥关系</li>
<li>不能保证变量状态的“原子性操作”</li>
</ol>
</li>
</ul>
<pre><code class="lang-java hljs"><span class="hljs-comment">/*
 * 一、volatile 关键字：当多个线程进行操作共享数据时，可以保证内存中的数据可见。相较于 synchronized 是一种较为轻量级的同步策略。
 * 注意：
 * 1. volatile 不具备“互斥性”
 * 2. volatile 不能保证变量的“原子性”
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestVolatile</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		ThreadDemo td = <span class="hljs-keyword">new</span> ThreadDemo();
		<span class="hljs-keyword">new</span> Thread(td).start();

		<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
			<span class="hljs-keyword">if</span>(td.isFlag()){
				System.out.println(<span class="hljs-string">"------------------"</span>);
				<span class="hljs-keyword">break</span>;
			}
		}

	}

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{

		<span class="hljs-keyword">try</span> {
			Thread.sleep(<span class="hljs-number">200</span>);
		} <span class="hljs-keyword">catch</span> (InterruptedException e) {
		}

		flag = <span class="hljs-keyword">true</span>;
		System.out.println(<span class="hljs-string">"flag="</span> + isFlag());

	}

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFlag</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">return</span> flag;
	}

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlag</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag)</span> </span>{
		<span class="hljs-keyword">this</span>.flag = flag;
	}

}
</code></pre>
<h2 id="toc_7">CAS 算法<a class="vnote-anchor" href="#toc_7" data-anchor-icon="#"></a></h2>
<p>CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。</p>
<p>CAS 是一种无锁的非阻塞算法的实现。</p>
<p>CAS 包含了3 个操作数：</p>
<ul>
<li>需要读写的内存值V</li>
<li>进行比较的值A</li>
<li>拟写入的新值B</li>
</ul>
<p>当且仅当V 的值等于A 时，CAS 通过原子方式用新值B 来更新V 的值，否则不会执行任何操作。</p>
<pre><code class="lang-java hljs">
<span class="hljs-comment">/*
 * 模拟 CAS 算法
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCompareAndSwap</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		<span class="hljs-keyword">final</span> CompareAndSwap cas = <span class="hljs-keyword">new</span> CompareAndSwap();

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
			<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {

				<span class="hljs-meta">@Override</span>
				<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
					<span class="hljs-keyword">int</span> expectedValue = cas.get();
					<span class="hljs-keyword">boolean</span> b = cas.compareAndSet(expectedValue, (<span class="hljs-keyword">int</span>)(Math.random() * <span class="hljs-number">101</span>));
					System.out.println(b);
				}
			}).start();
		}

	}

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompareAndSwap</span></span>{
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;

	<span class="hljs-comment">//获取内存值</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>{
		<span class="hljs-keyword">return</span> value;
	}

	<span class="hljs-comment">//比较</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareAndSwap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expectedValue, <span class="hljs-keyword">int</span> newValue)</span></span>{
		<span class="hljs-keyword">int</span> oldValue = value;

		<span class="hljs-keyword">if</span>(oldValue == expectedValue){
			<span class="hljs-keyword">this</span>.value = newValue;
		}

		<span class="hljs-keyword">return</span> oldValue;
	}

	<span class="hljs-comment">//设置</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expectedValue, <span class="hljs-keyword">int</span> newValue)</span></span>{
		<span class="hljs-keyword">return</span> expectedValue == compareAndSwap(expectedValue, newValue);
	}
}

</code></pre>
<h3 id="toc_8">原子变量<a class="vnote-anchor" href="#toc_8" data-anchor-icon="#"></a></h3>
<p>类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可将volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。</p>
<p>类AtomicBoolean、AtomicInteger、AtomicLong 和AtomicReference 的实例各自提供对相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。</p>
<p>AtomicIntegerArray、AtomicLongArray 和AtomicReferenceArray 类进一步扩展了原子操作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方面也引人注目，这对于普通数组来说是不受支持的。</p>
<p><span style="color:red">核心方法：boolean compareAndSet(expectedValue, updateValue)</span></p>
<p>java.util.concurrent.atomic 包下提供了一些原子操作的常用类:</p>
<ul>
<li>AtomicBoolean 、AtomicInteger 、AtomicLong 、AtomicReference</li>
<li>AtomicIntegerArray 、AtomicLongArray</li>
<li>AtomicMarkableReference</li>
<li>AtomicReferenceArray</li>
<li>AtomicStampedReference</li>
</ul>
<pre><code class="lang-java hljs">
<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;

<span class="hljs-comment">/*
 * 一、i++ 的原子性问题：i++ 的操作实际上分为三个步骤“读-改-写”
 * 		  int i = 10;
 * 		  i = i++; //10
 * 
 * 		  int temp = i;
 * 		  i = i + 1;
 * 		  i = temp;
 * 
 * 二、原子变量：在 java.util.concurrent.atomic 包下提供了一些原子变量。
 * 		1. volatile 保证内存可见性
 * 		2. CAS（Compare-And-Swap） 算法保证数据变量的原子性
 * 			CAS 算法是硬件对于并发操作的支持
 * 			CAS 包含了三个操作数：
 * 			①内存值  V
 * 			②预估值  A
 * 			③更新值  B
 * 			当且仅当 V == A 时， V = B; 否则，不会执行任何操作。
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAtomicDemo</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		AtomicDemo ad = <span class="hljs-keyword">new</span> AtomicDemo();

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
			<span class="hljs-keyword">new</span> Thread(ad).start();
		}
	}

}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>{

<span class="hljs-comment">//	private volatile int serialNumber = 0;</span>

	<span class="hljs-keyword">private</span> AtomicInteger serialNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{

		<span class="hljs-keyword">try</span> {
			Thread.sleep(<span class="hljs-number">200</span>);
		} <span class="hljs-keyword">catch</span> (InterruptedException e) {
		}

		System.out.println(getSerialNumber());
	}

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSerialNumber</span><span class="hljs-params">()</span></span>{
		<span class="hljs-keyword">return</span> serialNumber.getAndIncrement();
	}


}
</code></pre>
<h3 id="toc_9">锁分段机制<a class="vnote-anchor" href="#toc_9" data-anchor-icon="#"></a></h3>
<p>Java 5.0 在java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。</p>
<p>ConcurrentHashMap 同步容器类是Java 5 增加的一个线程安全的哈希表。对与多线程的操作，介于HashMap 与Hashtable 之间。内部采用“锁分段"机制替代Hashtable 的独占锁。进而提高性能。</p>
<p>此包还提供了设计用于多线程上下文中的Collection 实现：</p>
<p>ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和CopyOnWriteArraySet。当期望许多线程访问一个给定collection 时，ConcurrentHashMap 通常优于同步的HashMap，ConcurrentSkipListMap 通常优于同步的TreeMap。当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList 优于同步的ArrayList。</p>
<pre><code class="lang-java hljs">
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;

<span class="hljs-comment">/*
 * CopyOnWriteArrayList/CopyOnWriteArraySet : “写入并复制”
 * 注意：添加操作多时，效率低，因为每次添加时都会进行复制，开销非常的大。并发迭代操作多时可以选择。
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCopyOnWriteArrayList</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		HelloThread ht = <span class="hljs-keyword">new</span> HelloThread();

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
			<span class="hljs-keyword">new</span> Thread(ht).start();
		}
	}

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>{

<span class="hljs-comment">//	private static List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;String&gt;());</span>

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CopyOnWriteArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();

	<span class="hljs-keyword">static</span>{
		list.add(<span class="hljs-string">"AA"</span>);
		list.add(<span class="hljs-string">"BB"</span>);
		list.add(<span class="hljs-string">"CC"</span>);
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{

		Iterator&lt;String&gt; it = list.iterator();

		<span class="hljs-keyword">while</span>(it.hasNext()){
			System.out.println(it.next());

			list.add(<span class="hljs-string">"AA"</span>);
		}

	}

}
</code></pre>
<h3 id="toc_10">CountDownLatch 闭锁<a class="vnote-anchor" href="#toc_10" data-anchor-icon="#"></a></h3>
<p>CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</p>
<p>闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行：</p>
<ul>
<li>确保某个计算在其需要的所有资源都被初始化之后才继续执行;</li>
<li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动;</li>
<li>等待直到某个操作所有参与者都准备就绪再继续执行。</li>
</ul>
<pre><code class="lang-java hljs">
<span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;

<span class="hljs-comment">/*
 * CountDownLatch ：闭锁，在完成某些运算是，只有其他所有线程的运算全部完成，当前运算才继续执行
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCountDownLatch</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		<span class="hljs-keyword">final</span> CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">50</span>);
		LatchDemo ld = <span class="hljs-keyword">new</span> LatchDemo(latch);

		<span class="hljs-keyword">long</span> start = System.currentTimeMillis();

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) {
			<span class="hljs-keyword">new</span> Thread(ld).start();
		}

		<span class="hljs-keyword">try</span> {
			latch.await();
		} <span class="hljs-keyword">catch</span> (InterruptedException e) {
		}

		<span class="hljs-keyword">long</span> end = System.currentTimeMillis();

		System.out.println(<span class="hljs-string">"耗费时间为："</span> + (end - start));
	}

}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LatchDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{

	<span class="hljs-keyword">private</span> CountDownLatch latch;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LatchDemo</span><span class="hljs-params">(CountDownLatch latch)</span> </span>{
		<span class="hljs-keyword">this</span>.latch = latch;
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{

		<span class="hljs-keyword">try</span> {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000</span>; i++) {
				<span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
					System.out.println(i);
				}
			}
		} <span class="hljs-keyword">finally</span> {
			latch.countDown();
		}

	}

}
</code></pre>
<h2 id="toc_11">Callable 接口<a class="vnote-anchor" href="#toc_11" data-anchor-icon="#"></a></h2>
<p>Java 5.0 在java.util.concurrent 提供了一个新的创建执行线程的方式：Callable 接口</p>
<p>Callable 接口类似于Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是Runnable 不会返回结果，并且无法抛出经过检查的异常。</p>
<p>Callable 需要依赖FutureTask ，FutureTask 也可以用作闭锁</p>
<pre><code class="lang-java hljs">
<span class="hljs-keyword">import</span> java.util.concurrent.Callable;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;
<span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;

<span class="hljs-comment">/*
 * 一、创建执行线程的方式三：实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。
 * 二、执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。  FutureTask 是  Future 接口的实现类
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCallable</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		ThreadDemo td = <span class="hljs-keyword">new</span> ThreadDemo();

		<span class="hljs-comment">//1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。</span>
		FutureTask&lt;Integer&gt; result = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(td);

		<span class="hljs-keyword">new</span> Thread(result).start();

		<span class="hljs-comment">//2.接收线程运算后的结果</span>
		<span class="hljs-keyword">try</span> {
			Integer sum = result.get();  <span class="hljs-comment">//FutureTask 可用于 闭锁</span>
			System.out.println(sum);
			System.out.println(<span class="hljs-string">"------------------------------------"</span>);
		} <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) {
			e.printStackTrace();
		}
	}

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>{

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100000</span>; i++) {
			sum += i;
		}

		<span class="hljs-keyword">return</span> sum;
	}

}

<span class="hljs-comment">/*class ThreadDemo implements Runnable{

	@Override
	public void run() {
	}

}*/</span>
</code></pre>
<h2 id="toc_12">显示锁Lock<a class="vnote-anchor" href="#toc_12" data-anchor-icon="#"></a></h2>
<p>在Java 5.0 之前，协调共享对象的访问时可以使用的机制只有synchronized 和volatile 。Java 5.0 后增加了一些新的机制，但并不是一种替代内置锁的方法，而是当内置锁不适用时，作为一种可选择的高级功能</p>
<p>ReentrantLock 实现了Lock 接口，并提供了与synchronized 相同的互斥性和内存可见性。但相较于synchronized 提供了更高的处理锁的灵活性。</p>
<p>Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个Lock 可能与多个Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的Object 版本中的不同。</p>
<p>在Condition 对象中，与wait、notify 和notifyAll 方法对应的分别是await、signal 和signalAll。</p>
<p>Condition 实例实质上被绑定到一个锁上。要为特定Lock 实例获得Condition 实例，请使用其newCondition() 方法。</p>
<pre><code class="lang-java hljs">
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;

<span class="hljs-comment">/*
 * 一、用于解决多线程安全问题的方式：
 * synchronized:隐式锁
 * 1. 同步代码块
 * 2. 同步方法
 * jdk 1.5 后：
 * 3. 同步锁 Lock
 * 注意：是一个显示锁，需要通过 lock() 方法上锁，必须通过 unlock() 方法进行释放锁
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLock</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		Ticket ticket = <span class="hljs-keyword">new</span> Ticket();

		<span class="hljs-keyword">new</span> Thread(ticket, <span class="hljs-string">"1号窗口"</span>).start();
		<span class="hljs-keyword">new</span> Thread(ticket, <span class="hljs-string">"2号窗口"</span>).start();
		<span class="hljs-keyword">new</span> Thread(ticket, <span class="hljs-string">"3号窗口"</span>).start();
	}

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>{

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tick = <span class="hljs-number">100</span>;

	<span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){

			lock.lock(); <span class="hljs-comment">//上锁</span>

			<span class="hljs-keyword">try</span>{
				<span class="hljs-keyword">if</span>(tick &gt; <span class="hljs-number">0</span>){
					<span class="hljs-keyword">try</span> {
						Thread.sleep(<span class="hljs-number">200</span>);
					} <span class="hljs-keyword">catch</span> (InterruptedException e) {
					}

					System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 完成售票，余票为："</span> + --tick);
				}
			}<span class="hljs-keyword">finally</span>{
				lock.unlock(); <span class="hljs-comment">//释放锁</span>
			}
		}
	}

}
</code></pre>
<blockquote>
<p>虚假唤醒问题</p>
</blockquote>
<pre><code class="lang-java hljs">
<span class="hljs-comment">/*
 * 生产者和消费者案例
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestProductorAndConsumer</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		Clerk clerk = <span class="hljs-keyword">new</span> Clerk();

		Productor pro = <span class="hljs-keyword">new</span> Productor(clerk);
		Consumer cus = <span class="hljs-keyword">new</span> Consumer(clerk);

		<span class="hljs-keyword">new</span> Thread(pro, <span class="hljs-string">"生产者 A"</span>).start();
		<span class="hljs-keyword">new</span> Thread(cus, <span class="hljs-string">"消费者 B"</span>).start();

		<span class="hljs-keyword">new</span> Thread(pro, <span class="hljs-string">"生产者 C"</span>).start();
		<span class="hljs-keyword">new</span> Thread(cus, <span class="hljs-string">"消费者 D"</span>).start();
	}

}

<span class="hljs-comment">//店员</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clerk</span></span>{
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> product = <span class="hljs-number">0</span>;

	<span class="hljs-comment">//进货</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>{<span class="hljs-comment">//循环次数：0</span>
		<span class="hljs-keyword">while</span>(product &gt;= <span class="hljs-number">1</span>){<span class="hljs-comment">//为了避免虚假唤醒问题，应该总是使用在循环中</span>
			System.out.println(<span class="hljs-string">"产品已满！"</span>);

			<span class="hljs-keyword">try</span> {
				<span class="hljs-keyword">this</span>.wait();
			} <span class="hljs-keyword">catch</span> (InterruptedException e) {
			}

		}

		System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" : "</span> + ++product);
		<span class="hljs-keyword">this</span>.notifyAll();
	}

	<span class="hljs-comment">//卖货</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span></span>{<span class="hljs-comment">//product = 0; 循环次数：0</span>
		<span class="hljs-keyword">while</span>(product &lt;= <span class="hljs-number">0</span>){
			System.out.println(<span class="hljs-string">"缺货！"</span>);

			<span class="hljs-keyword">try</span> {
				<span class="hljs-keyword">this</span>.wait();
			} <span class="hljs-keyword">catch</span> (InterruptedException e) {
			}
		}

		System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" : "</span> + --product);
		<span class="hljs-keyword">this</span>.notifyAll();
	}
}

<span class="hljs-comment">//生产者</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Productor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>{
	<span class="hljs-keyword">private</span> Clerk clerk;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Productor</span><span class="hljs-params">(Clerk clerk)</span> </span>{
		<span class="hljs-keyword">this</span>.clerk = clerk;
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) {
			<span class="hljs-keyword">try</span> {
				Thread.sleep(<span class="hljs-number">200</span>);
			} <span class="hljs-keyword">catch</span> (InterruptedException e) {
			}

			clerk.get();
		}
	}
}

<span class="hljs-comment">//消费者</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>{
	<span class="hljs-keyword">private</span> Clerk clerk;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(Clerk clerk)</span> </span>{
		<span class="hljs-keyword">this</span>.clerk = clerk;
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) {
			clerk.sale();
		}
	}
}
</code></pre>
<blockquote>
<p>lock锁案例</p>
</blockquote>
<pre><code class="lang-java hljs">
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;

<span class="hljs-comment">/*
 * 生产者消费者案例：
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestProductorAndConsumerForLock</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		Clerk clerk = <span class="hljs-keyword">new</span> Clerk();

		Productor pro = <span class="hljs-keyword">new</span> Productor(clerk);
		Consumer con = <span class="hljs-keyword">new</span> Consumer(clerk);

		<span class="hljs-keyword">new</span> Thread(pro, <span class="hljs-string">"生产者 A"</span>).start();
		<span class="hljs-keyword">new</span> Thread(con, <span class="hljs-string">"消费者 B"</span>).start();

<span class="hljs-comment">//		 new Thread(pro, "生产者 C").start();</span>
<span class="hljs-comment">//		 new Thread(con, "消费者 D").start();</span>
	}

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clerk</span> </span>{
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> product = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();
	<span class="hljs-keyword">private</span> Condition condition = lock.newCondition();

	<span class="hljs-comment">// 进货</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>{
		lock.lock();

		<span class="hljs-keyword">try</span> {
			<span class="hljs-keyword">if</span> (product &gt;= <span class="hljs-number">1</span>) { <span class="hljs-comment">// 为了避免虚假唤醒，应该总是使用在循环中。</span>
				System.out.println(<span class="hljs-string">"产品已满！"</span>);

				<span class="hljs-keyword">try</span> {
					condition.await();
				} <span class="hljs-keyword">catch</span> (InterruptedException e) {
				}

			}
			System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" : "</span>
					+ ++product);

			condition.signalAll();
		} <span class="hljs-keyword">finally</span> {
			lock.unlock();
		}

	}

	<span class="hljs-comment">// 卖货</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>{
		lock.lock();

		<span class="hljs-keyword">try</span> {
			<span class="hljs-keyword">if</span> (product &lt;= <span class="hljs-number">0</span>) {
				System.out.println(<span class="hljs-string">"缺货！"</span>);

				<span class="hljs-keyword">try</span> {
					condition.await();
				} <span class="hljs-keyword">catch</span> (InterruptedException e) {
				}
			}

			System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" : "</span>
					+ --product);

			condition.signalAll();

		} <span class="hljs-keyword">finally</span> {
			lock.unlock();
		}
	}
}

<span class="hljs-comment">// 生产者</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Productor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{

	<span class="hljs-keyword">private</span> Clerk clerk;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Productor</span><span class="hljs-params">(Clerk clerk)</span> </span>{
		<span class="hljs-keyword">this</span>.clerk = clerk;
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) {
			<span class="hljs-keyword">try</span> {
				Thread.sleep(<span class="hljs-number">200</span>);
			} <span class="hljs-keyword">catch</span> (InterruptedException e) {
				e.printStackTrace();
			}

			clerk.get();
		}
	}
}

<span class="hljs-comment">// 消费者</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{

	<span class="hljs-keyword">private</span> Clerk clerk;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(Clerk clerk)</span> </span>{
		<span class="hljs-keyword">this</span>.clerk = clerk;
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) {
			clerk.sale();
		}
	}

}
</code></pre>
<h3 id="toc_13">线程按序交替<a class="vnote-anchor" href="#toc_13" data-anchor-icon="#"></a></h3>
<p>编写一个程序，开启3 个线程，这三个线程的ID 分别为A、B、C，每个线程将自己的ID 在屏幕上打印10 遍，要求输出的结果必须按顺序显示。</p>
<p>如：ABCABCABC…… 依次递归</p>
<pre><code class="lang-java hljs">
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestABCAlternate</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		AlternateDemo ad = <span class="hljs-keyword">new</span> AlternateDemo();

		<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {
			<span class="hljs-meta">@Override</span>
			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{

				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++) {
					ad.loopA(i);
				}

			}
		}, <span class="hljs-string">"A"</span>).start();

		<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {
			<span class="hljs-meta">@Override</span>
			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{

				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++) {
					ad.loopB(i);
				}
			}
		}, <span class="hljs-string">"B"</span>).start();

		<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {
			<span class="hljs-meta">@Override</span>
			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{

				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++) {
					ad.loopC(i);

					System.out.println(<span class="hljs-string">"-----------------------------------"</span>);
				}

			}
		}, <span class="hljs-string">"C"</span>).start();
	}

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlternateDemo</span></span>{

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>; <span class="hljs-comment">//当前正在执行线程的标记</span>

	<span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();
	<span class="hljs-keyword">private</span> Condition condition1 = lock.newCondition();
	<span class="hljs-keyword">private</span> Condition condition2 = lock.newCondition();
	<span class="hljs-keyword">private</span> Condition condition3 = lock.newCondition();

	<span class="hljs-comment">/**
	 * <span class="hljs-doctag">@param</span> totalLoop : 循环第几轮
	 */</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loopA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> totalLoop)</span></span>{
		lock.lock();

		<span class="hljs-keyword">try</span> {
			<span class="hljs-comment">//1. 判断</span>
			<span class="hljs-keyword">if</span>(number != <span class="hljs-number">1</span>){
				condition1.await();
			}

			<span class="hljs-comment">//2. 打印</span>
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1</span>; i++) {
				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"\t"</span> + i + <span class="hljs-string">"\t"</span> + totalLoop);
			}

			<span class="hljs-comment">//3. 唤醒</span>
			number = <span class="hljs-number">2</span>;
			condition2.signal();
		} <span class="hljs-keyword">catch</span> (Exception e) {
			e.printStackTrace();
		} <span class="hljs-keyword">finally</span> {
			lock.unlock();
		}
	}

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loopB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> totalLoop)</span></span>{
		lock.lock();

		<span class="hljs-keyword">try</span> {
			<span class="hljs-comment">//1. 判断</span>
			<span class="hljs-keyword">if</span>(number != <span class="hljs-number">2</span>){
				condition2.await();
			}

			<span class="hljs-comment">//2. 打印</span>
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1</span>; i++) {
				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"\t"</span> + i + <span class="hljs-string">"\t"</span> + totalLoop);
			}

			<span class="hljs-comment">//3. 唤醒</span>
			number = <span class="hljs-number">3</span>;
			condition3.signal();
		} <span class="hljs-keyword">catch</span> (Exception e) {
			e.printStackTrace();
		} <span class="hljs-keyword">finally</span> {
			lock.unlock();
		}
	}

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loopC</span><span class="hljs-params">(<span class="hljs-keyword">int</span> totalLoop)</span></span>{
		lock.lock();

		<span class="hljs-keyword">try</span> {
			<span class="hljs-comment">//1. 判断</span>
			<span class="hljs-keyword">if</span>(number != <span class="hljs-number">3</span>){
				condition3.await();
			}

			<span class="hljs-comment">//2. 打印</span>
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1</span>; i++) {
				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"\t"</span> + i + <span class="hljs-string">"\t"</span> + totalLoop);
			}

			<span class="hljs-comment">//3. 唤醒</span>
			number = <span class="hljs-number">1</span>;
			condition1.signal();
		} <span class="hljs-keyword">catch</span> (Exception e) {
			e.printStackTrace();
		} <span class="hljs-keyword">finally</span> {
			lock.unlock();
		}
	}

}
</code></pre>
<h2 id="toc_14">读-写锁<a class="vnote-anchor" href="#toc_14" data-anchor-icon="#"></a></h2>
<p>ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有writer，读取锁可以由多个reader 线程同时保持。写入锁是独占的。</p>
<p>ReadWriteLock 读取操作通常不会改变共享资源，但执行写入操作时，必须独占方式来获取锁。对于读取操作占多数的数据结构。ReadWriteLock 能提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作。</p>
<pre><code class="lang-java hljs">
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReadWriteLock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;

<span class="hljs-comment">/*
 * 1. ReadWriteLock : 读写锁
 * 写写/读写 需要“互斥”
 * 读读 不需要互斥
 *
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestReadWriteLock</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		ReadWriteLockDemo rw = <span class="hljs-keyword">new</span> ReadWriteLockDemo();

		<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {

			<span class="hljs-meta">@Override</span>
			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
				rw.set((<span class="hljs-keyword">int</span>)(Math.random() * <span class="hljs-number">101</span>));
			}
		}, <span class="hljs-string">"Write:"</span>).start();

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
			<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {

				<span class="hljs-meta">@Override</span>
				<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
					rw.get();
				}
			}).start();
		}
	}

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockDemo</span></span>{

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">private</span> ReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();

	<span class="hljs-comment">//读</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>{
		lock.readLock().lock(); <span class="hljs-comment">//上锁</span>

		<span class="hljs-keyword">try</span>{
			System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" : "</span> + number);
		}<span class="hljs-keyword">finally</span>{
			lock.readLock().unlock(); <span class="hljs-comment">//释放锁</span>
		}
	}

	<span class="hljs-comment">//写</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>{
		lock.writeLock().lock();

		<span class="hljs-keyword">try</span>{
			System.out.println(Thread.currentThread().getName());
			<span class="hljs-keyword">this</span>.number = number;
		}<span class="hljs-keyword">finally</span>{
			lock.writeLock().unlock();
		}
	}
}
</code></pre>
<h2 id="toc_15">线程池<a class="vnote-anchor" href="#toc_15" data-anchor-icon="#"></a></h2>
<p>线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。</p>
<p>第四种获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。</p>
<p>线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。</p>
<p>线程池的体系结构：</p>
<pre><code class="hljs">java.util.concurrent.Executor : 负责线程的使用与调度的根接口
	|--ExecutorService 子接口: 线程池的主要接口
		|--ThreadPoolExecutor 线程池的实现类
		|--ScheduledExecutorService 子接口：负责线程的调度
				|--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService
</code></pre>
<p>工具类 : Executors</p>
<ul>
<li>ExecutorService newFixedThreadPool() : 创建固定大小的线程池</li>
<li>ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。</li>
<li>ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程</li>
<li>ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。</li>
</ul>
<pre><code class="lang-java hljs"><span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.concurrent.Callable;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;
<span class="hljs-keyword">import</span> java.util.concurrent.Future;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThreadPool</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
		<span class="hljs-comment">//1. 创建线程池</span>
		ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);

		List&lt;Future&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
			Future&lt;Integer&gt; future = pool.submit(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;(){

				<span class="hljs-meta">@Override</span>
				<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
					<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;

					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
						sum += i;
					}

					<span class="hljs-keyword">return</span> sum;
				}

			});

			list.add(future);
		}

		pool.shutdown();

		<span class="hljs-keyword">for</span> (Future&lt;Integer&gt; future : list) {
			System.out.println(future.get());
		}

		<span class="hljs-comment">/*ThreadPoolDemo tpd = new ThreadPoolDemo();

		//2. 为线程池中的线程分配任务
		for (int i = 0; i &lt; 10; i++) {
			pool.submit(tpd);
		}

		//3. 关闭线程池
		pool.shutdown();*/</span>
	}

<span class="hljs-comment">//	new Thread(tpd).start();</span>
<span class="hljs-comment">//	new Thread(tpd).start();</span>

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>{

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">while</span>(i &lt;= <span class="hljs-number">100</span>){
			System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" : "</span> + i++);
		}
	}

}

</code></pre>
<h2 id="toc_16">线程调度<a class="vnote-anchor" href="#toc_16" data-anchor-icon="#"></a></h2>
<pre><code class="lang-java hljs"><span class="hljs-keyword">import</span> java.util.Random;
<span class="hljs-keyword">import</span> java.util.concurrent.Callable;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;
<span class="hljs-keyword">import</span> java.util.concurrent.Future;
<span class="hljs-keyword">import</span> java.util.concurrent.ScheduledExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestScheduledThreadPool</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
		ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
			Future&lt;Integer&gt; result = pool.schedule(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;(){

				<span class="hljs-meta">@Override</span>
				<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
					<span class="hljs-keyword">int</span> num = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100</span>);<span class="hljs-comment">//生成随机数</span>
					System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" : "</span> + num);
					<span class="hljs-keyword">return</span> num;
				}

			}, <span class="hljs-number">1</span>, TimeUnit.SECONDS);

			System.out.println(result.get());
		}

		pool.shutdown();
	}

}

</code></pre>
<h2 id="toc_17">Fork/Join 框架<a class="vnote-anchor" href="#toc_17" data-anchor-icon="#"></a></h2>
<p>Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行join 汇总。</p>
<p><img src="_v_images/1552901271_23274.png" alt="" class="view-image"></p>
<p>Fork/Join 框架与线程池的区别</p>
<p>采用“工作窃取”模式（work-stealing）：</p>
<p>当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p>
<p>相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中，如果一个线程正在执行的任务由于某些<br>
原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间，提高了性能。</p>
<pre><code class="lang-java hljs">
<span class="hljs-keyword">import</span> java.time.Duration;
<span class="hljs-keyword">import</span> java.time.Instant;
<span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinPool;
<span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinTask;
<span class="hljs-keyword">import</span> java.util.concurrent.RecursiveTask;
<span class="hljs-keyword">import</span> java.util.stream.LongStream;

<span class="hljs-keyword">import</span> org.junit.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestForkJoinPool</span> </span>{

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		Instant start = Instant.now();

		ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool();

		ForkJoinTask&lt;Long&gt; task = <span class="hljs-keyword">new</span> ForkJoinSumCalculate(<span class="hljs-number">0L</span>, <span class="hljs-number">50000000000L</span>);

		Long sum = pool.invoke(task);

		System.out.println(sum);

		Instant end = Instant.now();

		System.out.println(<span class="hljs-string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="hljs-comment">//166-1996-10590</span>
	}

	<span class="hljs-meta">@Test</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>{
		Instant start = Instant.now();

		<span class="hljs-keyword">long</span> sum = <span class="hljs-number">0L</span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0L</span>; i &lt;= <span class="hljs-number">50000000000L</span>; i++) {
			sum += i;
		}

		System.out.println(sum);

		Instant end = Instant.now();

		System.out.println(<span class="hljs-string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="hljs-comment">//35-3142-15704</span>
	}

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkJoinSumCalculate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Long</span>&gt;</span>{


	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">259195479995561737L</span>;

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> start;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> end;

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> THURSHOLD = <span class="hljs-number">10000L</span>;  <span class="hljs-comment">//临界值</span>

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ForkJoinSumCalculate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> end)</span> </span>{
		<span class="hljs-keyword">this</span>.start = start;
		<span class="hljs-keyword">this</span>.end = end;
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> Long <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">long</span> length = end - start;

		<span class="hljs-keyword">if</span>(length &lt;= THURSHOLD){
			<span class="hljs-keyword">long</span> sum = <span class="hljs-number">0L</span>;

			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = start; i &lt;= end; i++) {
				sum += i;
			}

			<span class="hljs-keyword">return</span> sum;
		}<span class="hljs-keyword">else</span>{
			<span class="hljs-keyword">long</span> middle = (start + end) / <span class="hljs-number">2</span>;

			ForkJoinSumCalculate left = <span class="hljs-keyword">new</span> ForkJoinSumCalculate(start, middle);
			left.fork(); <span class="hljs-comment">//进行拆分，同时压入线程队列</span>

			ForkJoinSumCalculate right = <span class="hljs-keyword">new</span> ForkJoinSumCalculate(middle+<span class="hljs-number">1</span>, end);
			right.fork(); <span class="hljs-comment">//</span>

			<span class="hljs-keyword">return</span> left.join() + right.join();
		}
	}

}
</code></pre>

    </div>
</div>
</div>

<div id="container-floating" style="display:none;" class="d-none d-md-block d-xl-block">
    <div id="floating-button" onclick="toggleMore()">
        <p id="floating-more" class="more">&gt;</p>
    </div>
</div>

<!--
<div class="footer" id="vnote-footer">
    <p>Generated by <em><a href="https://tamlok.github.io/vnote/">VNote</a></em>.</p>
</div>
-->
</body>
</html>
