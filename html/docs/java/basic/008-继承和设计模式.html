<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="generator" content="VNote">

    <title>008-继承和设计模式</title>
    <link rel="icon" href="https://github.com/tamlok/vnote/raw/master/src/resources/icons/vnote.ico">

    <style type="text/css">
    /* STYLE_GLOBAL_PLACE_HOLDER */
    </style>

    <style type="text/css">
    /* STYLE_OUTLINE_PLACE_HOLDER */
    /* STYLE_PLACE_HOLDER */
    </style>

    <!-- EXTRA_PLACE_HOLDER -->

<!-- HEAD_PLACE_HOLDER -->
</head>
<body>
<div class="container-fluid">
<div class="row flex-xl-nowrap">
    <div id="outline-panel" style="display:none;" class="d-none d-md-block d-xl-block col-md-3 col-xl-2 bd-toc">
        <div id="outline-content" class="section-nav"></div>
    </div>
    <div id="post-content" class="col-12 col-md-9 col-xl-10 py-md-3 pl-md-5 bd-content">
    <h2 id="toc_0">继承<a class="vnote-anchor" href="#toc_0" data-anchor-icon="#"></a></h2>
<p>涉及到的关键字</p>
<pre><code class="lang-java hljs">extends、<span class="hljs-keyword">super</span>、<span class="hljs-keyword">this</span>
</code></pre>
<p>继承：使用extends关键字连接两个类,形成继承关系</p>
<p>代码清单：</p>
<p><img src="_v_images/20190310171039600_25390.png" alt="" class="view-image"></p>
<h3 id="toc_1">继承的特点<a class="vnote-anchor" href="#toc_1" data-anchor-icon="#"></a></h3>
<p>子类可以访问父类的非私有成员</p>
<p>当一个类被final修饰时,那么该类无法被继承,例如String</p>
<p>当一个成员方法被final修饰时,那么该方法无法被重写</p>
<p>Java中的继承关系只能单继承、但是可以是多层继承</p>
<p>Java中每个类都默认继承Object</p>
<p>重写</p>
<ul>
<li>子类将父类的方法重写书写</li>
<li>当产生重写之后我们在调用时,优先调用子类</li>
<li>重写的要求
<ul>
<li>访问权限大于等于父类的</li>
<li>返回值类型、方法名、参数列表必须和父类保持一致</li>
</ul>
</li>
</ul>
<h3 id="toc_2">继承中的构造方法<a class="vnote-anchor" href="#toc_2" data-anchor-icon="#"></a></h3>
<p>构造方法：1、方法名和类名保持一致	2、没有返回值</p>
<p>在继承关系中,子类的构造方法中的第一行默认调用父类的空参构造,如果父类没有,编译无法通过</p>
<p>super:表示父类对象</p>
<p>this：区分变量名冲突,表示本类对象的</p>
<p>代码清单：</p>
<p><img src="_v_images/20190310171437438_15128.png" alt="" class="view-image"></p>
<h2 id="toc_3">final关键字<a class="vnote-anchor" href="#toc_3" data-anchor-icon="#"></a></h2>
<p>可以修饰的成员有:成员变量、成员方法、类</p>
<p>书写规范：所有的字母全部大写,单词和单词之间以下划线连接</p>
<pre><code class="lang-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String STUDENT_NAME=”zs”;
</code></pre>
<h2 id="toc_4">练习<a class="vnote-anchor" href="#toc_4" data-anchor-icon="#"></a></h2>
<p>创建一个父类 Computer</p>
<ul>
<li>属性:name</li>
<li>方法：getInfo()</li>
<li>创建一个子类Laptop继承自Computer</li>
<li>创建测试类Test</li>
<li>创建Laptop类的对象调用name属性和getInfo 方法。</li>
</ul>
<p>创建一个账户Account类，</p>
<p>属性:</p>
<ul>
<li>id:账户号码,</li>
<li>password:账户密码,</li>
<li>name:真实姓名,</li>
<li>personId:身份证号码</li>
<li>email:客户的电子邮箱,</li>
<li>balance:账户余额.</li>
</ul>
<p>构造方法:</p>
<ul>
<li>有参和无参,有参构造方法用于设置必要的属性</li>
</ul>
<p>方法</p>
<ul>
<li>deposit: 存款方法,参数是double型的金额;</li>
<li>withdraw:取款方法,参数是double型的金额.</li>
</ul>
<p>定义员工类(Employee)</p>
<ul>
<li>属性：姓名、年龄、性别</li>
<li>构造方法</li>
<li>方法：重写toString()。</li>
<li>定义管理层类(manage)，继承员工类，</li>
<li>属性：
<ul>
<li>职务(post)</li>
<li>年薪(yearlySalary)        定义测试类打印输出所有的属性</li>
</ul>
</li>
</ul>
<p>设计一个台灯类Lamp(选作)</p>
<p>属性：灯泡(bulb)</p>
<p>方法：</p>
<ul>
<li>
<p>开灯:on</p>
</li>
<li>
<p>关灯:off</p>
</li>
<li>
<p>创建子类：红灯泡(RedBuble)和绿灯泡(GreenBuble)，他们都继承自灯泡类有一个发亮的方法(shin)</p>
</li>
<li>
<p>要求：请设计出一段代码可以使台灯开启灯泡发亮，并且保证替换不同种类的灯泡台灯类代码不被修改</p>
</li>
</ul>
<h2 id="toc_5">设计模式<a class="vnote-anchor" href="#toc_5" data-anchor-icon="#"></a></h2>
<p>概念：</p>
<p>所谓设计模式就是我们的前辈总结出的一套关于编程中常见问题的一些常规解决方式,Java中一共有23种常见的设计模式</p>
<h3 id="toc_6">单例设计模式：<a class="vnote-anchor" href="#toc_6" data-anchor-icon="#"></a></h3>
<p>概念：</p>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>适用场景</p>
<ul>
<li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</li>
<li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</li>
</ul>
<p>具体实现</p>
<ol>
<li>创建一个类的对象是通过构造方法实现的</li>
<li>将构造方法使用private修饰,杜绝在其他类中直接new对象</li>
<li>创建一个可以不通过对象调用的方法,该方法返回本类对象</li>
</ol>
<p>代码清单：</p>
<p><img src="_v_images/20190310172315726_18311.png" alt="" class="view-image"></p>
<h3 id="toc_7">模板方法设计模式<a class="vnote-anchor" href="#toc_7" data-anchor-icon="#"></a></h3>
<p>作用：</p>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>适用场景</p>
<ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。 最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li>
<li>控制子类扩展。</li>
</ul>
<p>代码清单：</p>
<p><img src="_v_images/20190310172423364_28964.png" alt="" class="view-image"><br>
<img src="_v_images/20190310172432037_9530.png" alt="" class="view-image"></p>
<h2 id="toc_8">抽象类<a class="vnote-anchor" href="#toc_8" data-anchor-icon="#"></a></h2>
<p>涉及到的关键字</p>
<pre><code class="lang-java hljs"><span class="hljs-keyword">abstract</span>
</code></pre>
<p>概述：</p>
<p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<p>抽象类的声明如下：</p>
<p><img src="_v_images/20190310172549980_23841.png" alt="" class="view-image"></p>
<p>抽象类的特点</p>
<ul>
<li>抽象类有构造方法,但是不能创建对象,该构造方法只是为了方便子类继承</li>
<li>抽象类中的抽象方法在子类中必须重写</li>
<li>抽象类中可以有非抽象方法和抽象方法,但是抽象方法只能放在抽象类中</li>
</ul>
<blockquote>
<p>注意：实际编程中,一般情况下父类大部分都是抽象类或者接口</p>
</blockquote>
<h2 id="toc_9">练习<a class="vnote-anchor" href="#toc_9" data-anchor-icon="#"></a></h2>
<p>编写一个Employee类，声明为抽象类，</p>
<ul>
<li>包含如下三个属性：name，id，salary。提供必要的构造器和抽象方法：work()。</li>
<li>对于Manager类来说，他既是员工，还具有奖金(bonus)的属性。</li>
<li>请使用继承的思想，设计CommonEmployee类和Manager类，要求类中提供必要的方法进行属性访问。</li>
</ul>

    </div>
</div>
</div>

<div id="container-floating" style="display:none;" class="d-none d-md-block d-xl-block">
    <div id="floating-button" onclick="toggleMore()">
        <p id="floating-more" class="more">&gt;</p>
    </div>
</div>

<!--
<div class="footer" id="vnote-footer">
    <p>Generated by <em><a href="https://tamlok.github.io/vnote/">VNote</a></em>.</p>
</div>
-->
</body>
</html>
