<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="generator" content="VNote">

    <title>017-反射机制</title>
    <link rel="icon" href="https://github.com/tamlok/vnote/raw/master/src/resources/icons/vnote.ico">

    <style type="text/css">
    /* STYLE_GLOBAL_PLACE_HOLDER */
    </style>

    <style type="text/css">
    /* STYLE_OUTLINE_PLACE_HOLDER */
    /* STYLE_PLACE_HOLDER */
    </style>

    <!-- EXTRA_PLACE_HOLDER -->

<!-- HEAD_PLACE_HOLDER -->
</head>
<body>
<div class="container-fluid">
<div class="row flex-xl-nowrap">
    <div id="outline-panel" style="display:none;" class="d-none d-md-block d-xl-block col-md-3 col-xl-2 bd-toc">
        <div id="outline-content" class="section-nav"></div>
    </div>
    <div id="post-content" class="col-12 col-md-9 col-xl-10 py-md-3 pl-md-5 bd-content">
    <h2 id="toc_0">反射机制<a class="vnote-anchor" href="#toc_0" data-anchor-icon="#"></a></h2>
<p>指的是可以于运行时加载、探知、使用编译期间完全未知的类</p>
<p>程序在运行状态中，可以动态加载一个只有名称的类，对于任意一个已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；</p>
<p>加载完类之后，在堆内存中，就产生了一个 Class 类型的对象（一个类只有一个 Class 对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</p>
<h2 id="toc_1">Class类介绍<a class="vnote-anchor" href="#toc_1" data-anchor-icon="#"></a></h2>
<p>java.lang.Class类十分特殊，用来表示java中类型(class/interface/enum/annotation/primitive type/void)本身。</p>
<ul>
<li>Class类的对象包含了某个被加载类的结构。一个被加载的类对应一个Class对象。</li>
<li>当一个class被加载，或当加载器（class loader）的defineClass()被JVM调用，JVM 便自动产生一个Class 对象。</li>
</ul>
<p>Class类是Reflection的根源。</p>
<ul>
<li>针对任何您想动态加载、运行的类，唯有先获得相应的Class 对象</li>
</ul>
<h2 id="toc_2">Class类对象如何获取<a class="vnote-anchor" href="#toc_2" data-anchor-icon="#"></a></h2>
<p>运用getClass()</p>
<p>运用Class.forName()（最常被使用）</p>
<p>运用.class 语法</p>
<h2 id="toc_3">反射机制的常见作用<a class="vnote-anchor" href="#toc_3" data-anchor-icon="#"></a></h2>
<p>动态加载类、动态获取类的信息（属性、方法、构造器）</p>
<p>动态构造对象</p>
<p>动态调用类和对象的任意方法、构造器</p>
<p>动态调用和处理属性</p>
<h3 id="toc_4">反射操作泛型<a class="vnote-anchor" href="#toc_4" data-anchor-icon="#"></a></h3>
<p>Java采用泛型擦除的机制来引入泛型。Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦。但是，一旦编译完成，所有的和泛型有关的类型全部</p>
<p>为了通过反射操作这些类型以迎合实际开发的需要，Java就新增了ParameterizedType，GenericArrayType，TypeVariable 和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。</p>
<p>ParameterizedType: 表示一种参数化的类型，比如Collection<code>&lt;String&gt;</code></p>
<p>GenericArrayType: 表示一种元素类型是参数化类型或者类型变量的数组类型</p>
<p>TypeVariable: 是各种类型变量的公共父接口</p>
<p>WildcardType: 代表一种通配符类型表达式，比如?, ? extends Number, ? super Integer【wildcard是一个单词：就是“通配符”】</p>
<h3 id="toc_5">处理注解<a class="vnote-anchor" href="#toc_5" data-anchor-icon="#"></a></h3>
<p>可以通过反射API:getAnnotations, getAnnotation获得相关的注解信息</p>
<pre><code class="lang-java hljs"><span class="hljs-comment">//获得类的所有有效注解</span>
Annotation[] annotations=clazz.getAnnotations();
<span class="hljs-keyword">for</span> (Annotation a : annotations) {
    System.out.println(a);
}
<span class="hljs-comment">//获得类的指定的注解</span>
SxtTable st = (SxtTable) clazz.getAnnotation(SxtTable.class);
System.out.println(st.value());
<span class="hljs-comment">//获得类的属性的注解</span>
Field f = clazz.getDeclaredField(<span class="hljs-string">"studentName"</span>);
SxtField sxtField = f.getAnnotation(SxtField.class);
System.out.println(sxtField.columnName()+<span class="hljs-string">"--"</span>+sxtField.type()+<span class="hljs-string">"--"</span>+sxtField.length());
</code></pre>
<h2 id="toc_6">反射机制的性能问题<a class="vnote-anchor" href="#toc_6" data-anchor-icon="#"></a></h2>
<p>setAccessible</p>
<ul>
<li>
<p>启用和禁用访问安全检查的开关,值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查。并不是为true就能访问为false就不能访问。</p>
</li>
<li>
<p>禁止安全检查，可以提高反射的运行速度。</p>
</li>
<li>
<p>可以考虑使用：cglib/javaassist字节码操作</p>
</li>
</ul>

    </div>
</div>
</div>

<div id="container-floating" style="display:none;" class="d-none d-md-block d-xl-block">
    <div id="floating-button" onclick="toggleMore()">
        <p id="floating-more" class="more">&gt;</p>
    </div>
</div>

<!--
<div class="footer" id="vnote-footer">
    <p>Generated by <em><a href="https://tamlok.github.io/vnote/">VNote</a></em>.</p>
</div>
-->
</body>
</html>
